function [coords] = generatePoisson2D(a,b,M,delta,varargin)
%   
% generatePoisson2D 
% 
% version:  1.1
% authors:  Dingeman van der Haven and Pim van der Hoorn
%
% Description:
% Generates a inhomogeneous 2D Poisson Point Process in a given rectangular 
% region. The region is split into two subregions A1 and A2 by a straight 
% line going through two points a and b. The density function is a step 
% function where region A1 has constant density mu1 and region A2 
% has constant density mu2.
%
% Input:
% a, b      Two 1x2 arrays (row vectors) corresponding to the coordinates
%           of the two points that define the dividing line 
% M         The expected total number of points to be generated
% delta     The relative fraction between the densities, mu2 = delta x mu1
% extBound  (Optional)  The external bound of the region given as
%           [[xmin, ymin]; [xmax, ymax]]
%           Default     The unit square [[0,0];[1,1]]
%
% Output:
% coords    A two dimensional array consisting of the coordinates of the
%           points generated by the Poisson Point Process
%
%{
DEPENDENCIES:
 - separatePointsByLine
 - computeAreaLeft
%}

%%  Parse input arguments

checkPoint = @(x) isnumeric(x) && (size(x,1) == 1 && size(x,2) == 2);
checkNumPoints = @(x) isnumeric(x) && x > 0;
checkDelta = @(x) isnumeric(x) && x > 0 && x < 1;
checkExtBounds = @(x) isnumeric(x) && (size(x,1) == 2 && size(x,2) == 2);

defaultSquare = [0 0; 1 1];

p = inputParser;
addRequired(p,'a',checkPoint);
addRequired(p,'b',checkPoint);
addRequired(p,'M',checkNumPoints);
addRequired(p,'delta',checkDelta);
addOptional(p,'extBounds',defaultSquare,checkExtBounds);

p.KeepUnmatched = true;
parse(p,a,b,M,delta,varargin{:});
extBounds = p.Results.extBounds;

%% Check density boundaries

% If the intersection points a and b are outside the boundaries of the 
% region we set them equal to the closest boundary point.

% First point a.
if (a(1) < extBounds(1,1) || a(1) > extBounds(2,1) ...
        || a(2) < extBounds(1,2) || a(2) > extBounds(2,2))

    a(1) = min(max(a(1),extBounds(1,1)),extBounds(2,1));
    a(2) = min(max(a(2),extBounds(1,2)),extBounds(2,2));

    warningStr = ['The provided point [a] not contained within the ' ...
        'specified region. It has been recomputed to' + a + ...
        ' to fit inside the region'];
    warning(warningStr);
end

% Then point b.
if (b(1) < extBounds(1,1) || b(1) > extBounds(2,1) ...
        || a(2) < extBounds(1,2) || b(2) > extBounds(2,2))

    b(1) = min(max(b(1),extBounds(1,1)),extBounds(2,1));
    b(2) = min(max(b(2),extBounds(1,2)),extBounds(2,2));

    warningStr = ['The provided point [b] not contained within the ' ...
        'specified region. It has been recomputed to' + b + ...
        ' to fit inside the region'];
    warning(warningStr);
end

%%  Setup the regions
% Set height, width and volume of the A and the two sub regions A1 and A2.
    
    H = abs(extBounds(1,2)-extBounds(2,2));     % Height
    W = abs(extBounds(1,1)-extBounds(2,1));     % Width
    A = H*W;                                    % Area
    
    A1 = computeAreaLeft(a,b,extBounds);        % Area of region A1
    A2 = A - A1;                                % Area of region A2

%%  Setup the Poisson density
%   We select mu1 and mu2 such that:
%   1. mu1 x A1 + mu2 x A2 = M
%   2. mu2 = delta x mu1
    
    mu1 = M/(A1+delta*A2);
    mu2 = delta*mu1;
    mustar = max(mu1,mu2);

%% Simulate the Poisson Point Process
% We first simulate a homogeneous Poisson Point Process on A with density
% mustar. Then we will thin this process to obtain the process with the
% given two-region densities.

% We first sample the number of points for the homogeneous Poisson Point 
% Process on A with density mustar.

    N = poissrnd(mustar*A);            %Actual number of non-thinned points

% Given N, the points in A are distributed uniformly. We first generate N 
% points in the unit square and then extend these to be uniform in the 
% given region.

    coords = rand(N,2);                %Random points in a unit square
    
% Adjust the x and y coordinates to make them uniform in the region. This
% is done by mapping x -> x*width + xmin and y -> y*height + ymin.
    
    coords(:,1) = (coords(:,1).*W) + extBounds(1,1); 
    coords(:,2) = (coords(:,2).*H) + extBounds(1,2); 
    
% Next we separate the points of P based on the line defined by the two
% points a and b. P is split into two arrays P1 and P2. P1 are the points
% to the left and P2 those to the right. The dimensions of P are equal to
% [P1; P2].
    
    [P1,P2] = separatePointsByLine(coords,a,b,extBounds);

% We now proceed to thin the process. We will keep a point in A_i with
% probability mu_i/mustar. For a given point, this is achieved by first 
% sampling uniform random variable U and then keeping the point if  U <=
% mu_i/mustar.

% Generate a two vectors of uniform random variables, one for each region.

    U1 = rand(size(P1,1),1);
    U2 = rand(size(P2,1),1);

% Reject points in the left region with probability mu1/mustar and in the 
% right region with mu2/mustar.

    L1 = U1 <= mu1/mustar;
    L2 = U2 <= mu2/mustar;
    
% Apply the rejection to the coordinates using logical indexing.

    P1 = P1(L1,:);
    P2 = P2(L2,:);

% The points of the Poisson Point Process

    coords = [P1; P2];
    
end

